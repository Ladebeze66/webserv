WEBSERV

Comprendre pourquoi les URLs commencent par HTTP

Projet consistant à écrire son propre serveur HTTP.

Introduction

Le protocole HTTP(Hypertext Transfer Protocol) est un protocole d'application pour les systèmes d'information distribués, collaboratifs et hypermédia.
HTTP est la base de la communication de données pour le World Wide Web, où les documents hypertextes incluent des hyperliens vers d'autres ressources auxquelles l'utilisateur peut facilement accéder, par exemple par un clic de souris ou en tapant sur l'écran dans un navigateur Web.
HTTP a été développé pour faciliter l'hypertexte et le World Wide Web.
La fonction principale d'un serveur Web est de stocker, traiter et livrer des pages Web aux clients.
La communication entre le client et le serveur s'effectue à l'aide du protocole HTTP.
Les pages livrées sont le plus souvent des documents HTML, qui peuvent inclure des images, des feuilles de style et des scripts en plus du contenu textuel.
Plusieurs serveurs Wev peuvent être utilisés pour un site Web à fort trafic.
Un agent d'utilisateur, généralement un navigateur Web ou un robot d'indexation Web, initie la communication en faisant une demande pour une ressource spécifique à l'aide de HTTP.
Le serveur répond par le contenu de cettre ressource ou par un message d'erreur s'il est incapable de le faire. La ressource est généralement un fichier réel sur le stockage secondaire du serveur, mais ce n'est pas nécessairement le cas et dépend de la manière dont le serveur Web est implémenté.

Partie obligatoire:
Nom du programme: webserv
Fichiers de rendu: Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp, des fichiers de configuration
Arguments: un fichier de configuration
Fonctions externes autorisées: Tout ce qui respecte la norme C++ 98.
execve: exécute un programme référencé par un fichier spécifié dans un nouveau contexte de processus.
dup et dup2: 'dup' duplique un descripteur de fichier, rendant une copie qui partage toutes les locks de fichiers et les positions de lecture/écriture avec l'original. 'dup2' fait de même mais permet de spécifier le nouveaau descripteur de fichier.
pipe: crée une paire de descripteurs de fichiers, reliés entre eux, permettant la communication unidirectionnelle(données écrites sur un descripteur peuvent être lues de l'autre).
strerror et gai_streerror: le premier traduit un code d'erreur numérique en un message explicatif. Le second fait de même pour les erreurs retournées par les fonctions de résolution d'adresse réseau.
errno: variable globale utilisée par de nombreuses fonctions du système pour indiquer le type d'erreur lorqu'une opération échoue.
fork: crée un nouveau processus en dupliquant le processus appelant.
socketpair: crée une paire de sockets connectés, permettant la communication bidirectionnelle.
htons, htonl, ntohs, ntohl: convertissent les valeurs entre l'ordre des octets hôte et l'ordre des octects réseau pour les short et les long.
select: permet à un programme de surveillers plusieurs descripteurs de fichiers, attendant qu'un ou plusieurs deviennent "prêts" pour une opération d'entrée/sortie.
poll: similaire à select, mais fournit plus de fonctionnalités et une meilleure échelle pour les systèmes avec de nombreux descripteurs.
epoll(epoll_create, epoll_ctl, epoll_wait): mécanisme d'entrée/sortie évènementiel utilisé pour suveiller plusieurs descipteurs sous Linux.
Kqueue(kqueue, kevent): interface similaire à epoll mais disponible sur les systèmes BSD pour surveiller divers types d'événements.
socket, accept, listen, send, recv: fonctions utilisées pour la communication sur les réseaux via des sockets.
chdir, bind, connect, getaddrinfo, freeaddrinfo: fonctions pour la manipulation  de répertoires, la liaison de sockets, la connexion, la résolution d'adresses, et la getion de la mémoire pour les structures d'adresse.
setsockopt, getsockname, getprotobyname, fcntl, close: fonctions pour configurer les options des sockets, obtenir des informations socket, manipuler les propriétés des fichiers et descripteurs.
read, write: fonctions de base pour lire et écrire des données sur des descripteurs de fichiers.
waitpid, kill, signal: fonxtions pour la gestion des processus, l'envoi de signaux et la manipulation des gestionnaires de signaux.
access, stat: fonctions pour vérifier les permissions d'accès et obtenir les informations de statut des fichiers.
open, opendir, readdir, closedir: fonctions pour ouvrir, lire, et fermer des fichiers et répertoires.

Vous devez écrire un serveur HTTP en C++ 98.

Bien que poll() soit mentionné dans le sujet et la grille d'évaluation, vous pouvez utiliser un équivalent tel que select(), kqueue(), ou epoll().

1. Stabilité et Gestion des Ressources

Consigne : Votre programme ne doit pas crasher, même en cas de manque de mémoire.

Approche : Utilisez une gestion d'erreurs exhaustive pour vérifier les retours de toutes les allocations de mémoire et opérations critiques. Assurez-vous de gérer correctement tous les cas d'erreur possibles pour éviter les comportements indéfinis.

Exemple :
int* ptr = new(std::nothrow) int;
if (!ptr) {
    std::cerr << "Allocation failed" << std::endl;
    exit(EXIT_FAILURE);
}

2. Makefile et Compilation

Consigne : Fournir un Makefile avec les règles spécifiques et compiler avec des flags restrictifs.

Approche : Créez un Makefile qui définit les cibles $(NAME), all, clean, fclean, et re. Assurez-vous que votre Makefile ne relink pas à chaque fois.

Exemple de Makefile :
NAME = webserv

SRCS = main.cpp Server.cpp Request.cpp Response.cpp
OBJS = $(SRCS:.cpp=.o)

CXX = g++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

all: $(NAME)

$(NAME): $(OBJS)
    $(CXX) $(CXXFLAGS) -o $@ $(OBJS)

clean:
    rm -f $(OBJS)

fclean: clean
    rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re

3. Respect de la Norme C++ 98

Consigne : Le code doit compiler avec le flag -std=c++98.

Approche : Évitez les fonctionnalités ajoutées dans les versions ultérieures du C++. Restez strict sur l'utilisation des bibliothèques et des fonctionnalités standardisées avant C++11.

Exemple :
Utilisez <vector> pour les tableaux dynamiques plutôt que les extensions spécifiques au compilateur.
Privilégiez l'utilisation de pointeurs intelligents manuellement gérés comme std::auto_ptr (bien que limité) pour la gestion de la mémoire.

4. Gestion des Sockets et des CGI

Consigne : Utilisez des fonctionnalités réseau de bas niveau et gérez les CGI.

Approche : Intégrez les systèmes de socket et les appels système pour les opérations de réseau. Pour les CGI, configurez le serveur pour qu'il puisse exécuter des scripts externes en fonction des extensions de fichier.

Exemple :
// Exemple simplifié d'initialisation d'un socket
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
if (sockfd < 0) {
    perror("Failed to create socket");
    exit(EXIT_FAILURE);
}

sockaddr_in server_addr;
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
server_addr.sin_port = htons(8080);

if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
    perror("Failed to bind");
    close(sockfd);
    exit(EXIT_FAILURE);
}

Veuillez lire la RFC et faire quelques tests avec telnet et NGINX avant de commencer ce projet. Même si vous n'avez pas à implémenter toute la RFC, cela vous aidera à développer les fonctionnatlités requises.

La RFC (Request for Comments) concernant le protocole HTTP est une série de documents qui décrivent les spécifications techniques du protocole utilisé par le World Wide Web. Pour un serveur web, les RFC les plus pertinentes sont celles qui décrivent HTTP/1.1, car elles fournissent une base détaillée sur la manière dont les requêtes et les réponses doivent être gérées.

RFCs importantes pour HTTP/1.1 :
RFC 7230 : Architecture et messages HTTP/1.1
Détaille la syntaxe des messages, le transport des messages, et la connexion entre les clients et les serveurs.
RFC 7231 : Sémantique et contenu
Définit les méthodes de requête (GET, POST, etc.), les codes de statut de réponse, et les en-têtes qui déterminent le contenu de la requête et de la réponse.
RFC 7232 : Gestion des conditions préalables
Spécifie des en-têtes tels que Last-Modified et ETag pour gérer le cache et les conditions de requête.
RFC 7233 : Gestion des plages de requêtes
Permet à un client de demander des portions spécifiques d'une ressource, ce qui est utile pour le téléchargement de gros fichiers.
RFC 7234 : Mise en cache
Décrit les comportements de mise en cache et les directives de cache, qui contrôlent la réutilisation des réponses.
RFC 7235 : Authentification
Explique comment les requêtes et les réponses doivent gérer l'authentification et la sécurisation des accès.

Pourquoi lire la RFC est utile ?
Compatibilité et Interopérabilité : Assurer que votre serveur peut interagir correctement avec d'autres clients et serveurs Internet.
Fiabilité : Comprendre les normes aide à prévenir les erreurs de communication et à gérer efficacement les erreurs et les situations exceptionnelles dans les requêtes ou les réponses.
Performance : Les RFC détaillent les meilleures pratiques pour optimiser les communications, comme la gestion efficace des connexions persistantes et la mise en cache.
Sécurité : Inclut des recommandations pour sécuriser les échanges, comme l'utilisation de HTTPS et les méthodes d'authentification(cf documents RCF importants en pièce jointe).

En comprenant bien ces documents, vous aurez une base solide pour développer un serveur web qui respecte les standards actuels.

Utilisation de Telnet
Telnet est un protocole réseau qui permet de communiquer avec un autre ordinateur sur un réseau. Il est souvent utilisé pour tester les serveurs web en envoyant manuellement des requêtes HTTP.

Tester des requêtes HTTP :
Ouvrez un terminal et tapez telnet [adresse IP ou nom de domaine] [port]. Par exemple : telnet localhost 80 pour accéder à un serveur local sur le port 80.
Une fois connecté, vous pouvez taper des requêtes HTTP. Par exemple, pour demander la racine du serveur :
GET / HTTP/1.1
Host: localhost

N'oubliez pas d'appuyer deux fois sur "Entrée" après avoir saisi l'en-tête "Host".
Comprendre les réponses :
Observez les réponses retournées par le serveur. Telnet vous permet de voir exactement ce que le serveur envoie en réponse à vos requêtes, ce qui est crucial pour comprendre comment gérer les requêtes dans votre serveur web.
Débogage :
Utilisez Telnet pour envoyer différentes sortes de requêtes HTTP à votre serveur et voyez comment il réagit. Cela peut vous aider à identifier et corriger des erreurs dans la gestion des requêtes.

Utilisation de NGINX
NGINX est un serveur web/populaire qui peut également servir de proxy inverse, de répartiteur de charge, etc. Il est reconnu pour sa légèreté et sa capacité à gérer un grand nombre de connexions simultanées.

Installation et configuration de base :
Installez NGINX sur votre système. Sous Ubuntu, cela peut se faire via sudo apt install nginx.
Configurez NGINX en modifiant le fichier de configuration, souvent situé dans /etc/nginx/nginx.conf ou /etc/nginx/sites-available/default.
Tester et apprendre :
Modifiez la configuration pour servir des pages HTML statiques ou pour agir comme proxy pour votre application C++. Testez ces configurations en accédant à votre serveur NGINX depuis un navigateur ou en utilisant Telnet.
Consultez la documentation de NGINX pour comprendre les différentes directives de configuration et comment elles influencent le comportement du serveur.
Simuler des environnements de production :
Utilisez NGINX comme façade pour votre serveur C++ pour simuler un environnement de production et voir comment votre serveur se comporte sous charge, comment il gère les erreurs, etc.

Prérequis
Votre programme doit prendre un fichier de configuration en argument ou utiliser un chemin par défaut.
Vous ne pouvez pas exécuter un autre serveur web.
Votre serveur ne doit jamais bloquer e t le client doit être correctement renvoyé si nécessaire.
Il doit être non bloquant et n'utiliser qu'un seul poll() (ou équivalent) pour toutes les opérations entrées/sorties entre le client et le serveur (listen inclus).
poll() (ou équivalent) doit vérifier la lecture et l'écriture en même temps.
Vous ne devriez jamais faire une opération de lecture ou une opération d'écriture sans passer par poll()(ou équivalent).
La vérification de la valeur de errno est strictement interdite après une opération de lecture et d'écriture.
Vous n'avez pas besoin d'utiliser poll()(ou équivalent) avant de lire votre fichier de configuration.

Comme vous pouvez utiliser des FD en mode non bloquant, il est possible d'avoir un serveur non bloquant avec read/recv ou <rite/send tout en n'ayant pas recours à poll()(ou équivalent).
Mais cela consommerait des ressources système inutilement.
Ainsi, si vous essayez d'utiliser read/recv ou write/send avec n'importe quel FD sans utiliser poll()(ou équivalent), votre note sera de 0.

Vous pouvez utiliser chaque macro et définir comme FD_SET, FD_CLR, FD_ISSET, FD_ZERO(comprendre ce qu'elles font et comment elles le font est très utile).
Votre serveur doit être compatible avec le navigateur web de votre choix.
Nous considérerons que NGINX est conforme à HTTP 1.1 et peut être utilisé pour comparer les en-têtes et les comportements de réponse.
Vos codes d'état de réponse HTTP doivent être exacts.
Votre serveur doit avoir des pages d'erreur par défaut si aucune n'est fournie.
Vous ne pouvez pas utiliser fork pour autre chose que CGI(comme PHP ou Python, etc).
Vous devriez pouvoir servir un site web entièrement statique.
Le client devrait pouvoir télécharger des fichiers.
Vous avez besoin au moins des méthodes GET, POST, et DELETE
Stress testez votre serveur, il doit rester disponible à tout prix.
Votre serveur doit pouvoir écouter sur plusieurs ports(cf. Fichier de configuration).

1. Gestion du fichier de configuration
Prérequis : Votre programme doit prendre un fichier de configuration en argument ou utiliser un chemin par défaut.

Explication : Le serveur doit pouvoir lire les paramètres de configuration à partir d'un fichier spécifié par l'utilisateur lors du démarrage, ou utiliser un fichier de configuration par défaut si aucun n'est spécifié. Ces paramètres peuvent inclure le port d'écoute, les chemins des dossiers de ressources, les règles de sécurité, etc.
Exemple :
./webserver -config /path/to/config.file
Si aucun fichier n'est spécifié :
./webserver  # Utilise le chemin par défaut, par exemple /etc/webserver/config.file

Conseil : Utilisez un format de fichier de configuration simple comme JSON ou YAML, qui sont faciles à parser et maintenir. Pour C++, des bibliothèques comme nlohmann/json pour JSON ou yaml-cpp pour YAML peuvent être utilisées.
Exemple :
Supposons que votre fichier de configuration JSON ressemble à ceci :
{
  "server": {
    "port": 8080,
    "root": "/var/www/html"
  }
}
En C++, parsez ce fichier lors du démarrage du serveur :
#include <nlohmann/json.hpp>
#include <fstream>

nlohmann::json config;
std::ifstream i("config.file");
i >> config;
int port = config["server"]["port"];
std::string root = config["server"]["root"];

2. Exclusivité du serveur
Prérequis : Vous ne pouvez pas exécuter un autre serveur web.

Explication : Votre serveur web doit être le seul processus serveur HTTP écoutant sur les ports spécifiés pour éviter les conflits de ports et les problèmes de sécurité.

Conseil : Assurez-vous que le port spécifié dans votre fichier de configuration n'est pas déjà utilisé. Vous pouvez le faire en tentant de lier le socket au démarrage du serveur et en gérant les erreurs de liaison.
Exemple :
#include <sys/socket.h>
#include <netinet/in.h>
#include <iostream>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        std::cerr << "Erreur de liaison: le port est peut-être déjà utilisé." << std::endl;
        return 1;
    }
}

3. Serveur non bloquant
Prérequis : Votre serveur ne doit jamais bloquer et le client doit être correctement renvoyé si nécessaire. Il doit être non bloquant et utiliser un seul poll() pour toutes les opérations d'entrée/sortie.

Explication : Un serveur non bloquant utilise poll() ou un équivalent pour surveiller plusieurs descripteurs de fichiers à la fois et voir si l'écriture ou la lecture est possible. Si poll() indique que l'action est possible, le serveur peut alors exécuter cette action sans risque de bloquer.
Exemple :
struct pollfd fds[2];
int timeout_msecs = 5000;

fds[0].fd = FileDescriptor1;
fds[0].events = POLLIN;  // Data to read
fds[1].fd = FileDescriptor2;
fds[1].events = POLLOUT; // Ready to write

poll(fds, 2, timeout_msecs);

Conseil : Utilisez poll() pour gérer simultanément plusieurs connexions sur un seul thread. Assurez-vous que toutes les sockets sont en mode non bloquant.
Exemple :
#include <poll.h>
#include <vector>

struct pollfd pfd;
pfd.fd = sockfd;
pfd.events = POLLIN;
std::vector<struct pollfd> fds = {pfd};

while (true) {
    int ret = poll(fds.data(), fds.size(), 10000);  // Timeout de 10 secondes
    if (ret > 0) {
        if (fds[0].revents & POLLIN) {
            // Traiter la réception des données
        }
    }
}

4. Restrictions sur les opérations de lecture/écriture
Prérequis :
Vous ne devriez jamais faire une opération de lecture ou d’écriture sans passer par poll().
La vérification de la valeur de errno est strictement interdite après une opération de lecture ou d’écriture.

Explication : Cela garantit que les opérations de lecture et d'écriture sont prêtes à être effectuées et ne bloqueront pas le serveur, maintenant une haute disponibilité. Vérifier errno immédiatement après ces opérations pourrait entraîner des comportements incohérents si l'opération n'est pas prête.

Conseil : Ne lisez ou n'écrivez des données sur un socket qu'après que poll() a indiqué que les données sont disponibles pour éviter les blocages.
Exemple : Voir l'exemple précédent avec poll().

5. Utilisation des macros pour la gestion des descripteurs de fichiers
Prérequis : Vous pouvez utiliser chaque macro et définir comme FD_SET, FD_CLR, FD_ISSET, FD_ZERO.

Explication : Ces macros sont utilisées pour gérer des ensembles de descripteurs de fichiers avec select(), une alternative à poll(). Elles permettent d'ajouter des descripteurs à l'ensemble, de les retirer, de tester leur présence, et d'initialiser l'ensemble.
Exemple :
fd_set readfds;
FD_ZERO(&readfds);  // Clear the set
FD_SET(socket_fd, &readfds);  // Add socket_fd to the set

if (select(socket_fd+1, &readfds, NULL, NULL, NULL) > 0) {
    if (FD_ISSET(socket_fd, &readfds)) {
        // Read from socket_fd
    }
}

Conseil : Familiarisez-vous avec les opérations de base sur les ensembles de descripteurs avec FD_SET, FD_CLR, etc., surtout si vous utilisez select() à la place de poll().
Exemple :
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(sockfd, &readfds);

if (select(sockfd + 1, &readfds, NULL, NULL, NULL) > 0) {
    if (FD_ISSET(sockfd, &readfds)) {
        // Socket prêt à être lu
    }
}

6. Gestion des erreurs et compatibilité
Votre serveur doit avoir des pages d’erreur par défaut si aucune n’est fournie.
Vos codes d’état de réponse HTTP doivent être exacts.

Explication : Votre serveur doit être capable de renvoyer des réponses HTTP correctes, y compris les codes d'état appropriés pour chaque situation (200 pour OK, 404 pour Not Found, etc.), et fournir des pages d'erreur par défaut pour informer l'utilisateur de manière appropriée.

Conseil : Définissez clairement les messages d'erreur HTTP dans votre serveur. Utilisez une map ou un dictionnaire pour associer les codes d'état HTTP à leurs messages correspondants.
Exemple :
std::map<int, std::string> errorMessages;
errorMessages[404] = "Not Found";
errorMessages[500] = "Internal Server Error";

// En cas d'erreur :
int errorCode = 404;
send(client_fd, "HTTP/1.1 " + std::to_string(errorCode) + " " + errorMessages[errorCode], ...);

7. Fonctionnalités et robustesse
Le client devrait pouvoir télécharger des fichiers.
Vous avez besoin au moins des méthodes GET, POST, et DELETE.
Votre serveur doit pouvoir écouter sur plusieurs ports.
Stress testez votre serveur, il doit rester disponible à tout prix.

Explication : Votre serveur doit supporter les méthodes HTTP essentielles pour interagir avec les clients, permettre des téléchargements, et être résilient sous charge pour garantir qu'il reste opérationnel et réactif sous toutes conditions.

Conseil : Testez votre serveur sous charge avec des outils comme ApacheBench (ab) ou JMeter pour vous assurer qu'il reste stable et performant sous stress.
Exemple :
Utilisez ApacheBench pour stresser tester votre serveur :
ab -n 1000 -c 100 http://localhost:8080/
Ces conseils et exemples vous aideront à implémenter chaque prérequis de manière efficace et conforme aux attentes de votre projet de serveur web en C++.

Ces prérequis définissent les fonctionnalités essentielles et les bonnes pratiques pour le développement d'un serveur web robuste et efficace en C++. Le respect de ces directives assurera que votre serveur est performant, sécurisé, et fonctionnel.



Fichier de configuration

Vous pouvez vous inspirer de la partie "serveur" du fichier de configuration NGINX.

Dans ce fichier de configuration, vous devez pouvoir:

Choisir le port et l'host de chaque "serveur".

Setup server_names ou pas.

Le premier serveur pour un host:port sera le serveur par défaut pour cet host:port(ce qui signifie qu'il répondra à toutes les requêtes qui n'appartiennent pas à un autre serveur).

Setup des pages d'erreur par défaut.

Limiter la taille du body des clients.

Setup des routes avec une ou plusieurs des règles/configurations suivantes(les routes n'utiliseront pas de regexp):
Définir une liste de méthodes HTTP acceptées pour la route.
éfinir une redirection HTTP.
Définir un répertoire ou un fichier à partir duquel le fichier doit être recherché(par exemple si l'url /kapouet est rootée sur /tmp/www, l'url /kapouet/puic/toto/pouet est /tmp/www/pouic/toto/pouet).
Activer ou désactiver le listing des répertoires.
Set un fichier par défaut comme réponse si la requête est un répertoire.
Exécuter CGI en fonction de certaines extensions de fichier(par exemple .php).
Faites-le fonctionner avec les méthodes POST et GET.

Rendre la route capable d'accepter les fichiers téléchargés et configurer où cela doit être enregistré.
Vous vous demandez ce qu'est un CGI?
Parce que vous n'allez pas appeler le CGI mais utiliser directement le chemin complet comme PATH_INFO.
Souvenez-vous simplement que pour les requêtes fragmentées, votre serveur doit la dé-fragmenter et le CGI attendra EOF comme fin du body.
Même choses pour la sortie du CGI. Si aucun content_length n'est renvoyé par le CGI, EOF signifiera la fin des données renvoyées.
Votre programme doit appeler le CGI avec le fichier demandé comme premier argument.
Le CGI doit être exécuté dans le bon répertoire pour l'accès au fichier de chemin relatif.
Votre serveur devrait fonctionner avec un seul CGI(php-CGI, Python, etc.).

Vous devez fournir des fichiers de configuration et des fichiers de base par défaut pour tester et démontrer que chaque fonctionnalité fonctionne pendant l'évaluation.

Si vous avez une question sur un comportement, vous devez comparer le comportement de votre programme avec celui de NGINX.
Par exemple, vérifiez le fonctionnement du server_name.
Nous avons partagé avec vous un petit testeur. Il n'est pas obligatoire de le réussir à la perfection si tout fonctionne bien avec votre navigateur et vos tests, mais cela vous aider à résoudre certains bugs.
L'imporatant, c'est la résilience. Votre serveur ne devrait jamais mourir.
Ne testez pas un seul programme. Ecrivez vos tests avec un autre language comme Python ou Golang, etc... Vous pouvez même les faire en C ou C++.

Structure Générale du Fichier de Configuration

Pour structurer votre fichier de configuration, vous pourriez choisir un format comme JSON ou YAML, qui sont faciles à lire et à parser en C++. L'exemple ci-dessous utilise le format JSON pour sa clarté et sa facilité d'usage avec des bibliothèques modernes de parsing en C++.
Exemple de Fichier de Configuration
json
{
  "servers": [
    {
      "host": "localhost",
      "port": 8080,
      "server_names": ["example.com", "www.example.com"],
      "default_server": true,
      "error_pages": {
        "404": "/errors/404.html"
      },
      "max_body_size": 4000,
      "routes": [
        {
          "path": "/kapouet",
          "root": "/tmp/www",
          "methods": ["GET", "POST"],
          "redirect": "/newpath",
          "directory_listing": false,
          "default_file": "index.html",
          "cgi": {
            "enabled": true,
            "handler": "/path/to/php-cgi",
            "extensions": [".php"]
          },
          "upload": {
            "enabled": true,
            "save_path": "/uploads"
          }
        }
      ]
    }
  ]
}

Détails et Explications

1.Choix du port et de l'host

Explication : Chaque serveur peut écouter sur un port et un host spécifiques.

Conseil : Assurez-vous que les ports sont disponibles et que les hosts sont correctement configurés sur votre machine ou réseau.

Chaque instance de votre serveur web doit écouter sur un port spécifique lié à une adresse IP (host). L'host peut être une adresse IP locale comme 127.0.0.1 (localhost) ou une adresse IP publique, dépendant de l'accessibilité souhaitée du serveur.

Exemple :
"host": "192.168.1.1",
"port": 8080

2.Setup server_names

Explication : Les noms de serveur permettent de répondre différemment selon l'URL demandée.

Le server_name est utilisé pour répondre différemment selon le nom de domaine demandé par la requête HTTP. Cela permet à un seul serveur web de servir différents domaines.

Exemple :
"server_names": ["example.com", "www.example.com"]

Conseil : Utilisez des wildcards ou des noms spécifiques pour diriger le trafic efficacement.

3.Serveur par défaut pour un host:port

Explication : Le premier serveur listé pour un host et port spécifiques traitera toutes les requêtes non capturées par les autres configurations.

Conseil : Placez une configuration générique en premier pour capturer toute requête non spécifiée ailleurs.

Si plusieurs configurations de serveur écoutent sur le même host et port, le premier serveur spécifié dans le fichier de configuration est considéré comme le serveur par défaut.

Exemple :
"default_server": true

4.Pages d'erreur par défaut

Explication : Définissez des pages pour divers codes d'erreur HTTP.

Conseil : Assurez-vous que ces pages sont accessibles et testez leur affichage en provoquant des erreurs.

Définir des pages d'erreur personnalisées pour différents codes d'état HTTP améliore l'expérience utilisateur en fournissant des informations utiles lorsqu'une erreur se produit.

Exemple :
"error_pages": {
  "404": "/errors/404.html",
  "500": "/errors/500.html"
}

5.Limite de taille du corps des requêtes

Explication : Prévenez l'abus de ressources en limitant la taille du corps des requêtes POST.

Conseil : Définissez une limite raisonnable basée sur vos besoins d'application.

La limitation de la taille du corps des requêtes HTTP empêche les attaques par déni de service (DoS) qui tentent de surcharger le serveur avec de grandes quantités de données.

Exemple :
"max_body_size": 4000  // La taille maximale du corps en octets

6.Configuration des routes

Explication : Les routes dirigent les requêtes vers des ressources spécifiques sur le serveur.

Conseils :
Méthodes HTTP : Restreignez les méthodes acceptées pour renforcer la sécurité.
Redirections : Utilisez des redirections pour maintenir l'URL propre ou rediriger les anciennes pages.
Root et path : Associez des chemins d'URL à des répertoires physiques pour simplifier la gestion des ressources.
Listage de répertoire : Activez ou désactivez selon les besoins de confidentialité.
Fichier par défaut : Définissez un fichier à servir quand un répertoire est demandé.
CGI : Configurez pour exécuter des scripts dynamiques comme PHP ou Python.

Les routes définissent comment les requêtes sont traitées par le serveur, incluant les méthodes acceptées, les redirections, et la localisation des fichiers.

Méthodes HTTP
GET : Méthode pour récupérer des informations du serveur. Elle doit être sûre et idempotente, ce qui signifie qu'elle ne modifie pas les données.
POST : Méthode pour envoyer des données au serveur, souvent utilisée pour soumettre des formulaires.
DELETE : Méthode pour supprimer des ressources spécifiées.
Exemple :
"methods": ["GET", "POST"]
Redirection HTTP
Permet de rediriger les clients vers une nouvelle URL, souvent utilisée pour la maintenance du site ou après la réorganisation des pages.

Exemple :
"redirect": "/newpath"
Définition du répertoire racine
Spécifie où chercher les fichiers pour une route donnée.

Exemple :
"root": "/tmp/www"
Listing de répertoire
Contrôle si les contenus des répertoires sont listés ou non quand aucun fichier index n'est présent.

Exemple :
"directory_listing": false
Fichier par défaut
Spécifie un fichier à servir automatiquement lorsqu'un répertoire est demandé.

Exemple :
"default_file": "index.html"
Exécution de CGI
CGI (Common Gateway Interface) permet au serveur d'exécuter un script ou un programme externe pour générer des pages web dynamiques. C'est utilisé pour intégrer des applications comme PHP ou Python dans les pages servies.

Exemple :
"cgi": {
  "enabled": true,
  "handler": "/usr/bin/php-cgi",
  "extensions": [".php"]
}
Gestion des fichiers téléchargés
Permet au serveur de recevoir des fichiers envoyés par les clients et de les enregistrer dans un emplacement spécifié.

Exemple :
"upload": {
  "enabled": true,
  "save_path": "/uploads"
}
Ces configurations et définitions offrent une flexibilité et une sécurité pour votre serveur web en C++, permettant une personnalisation avancée et une gestion efficace des requêtes.

Test et Validation

Testeur et Tests Manuels : Utilisez des scripts en Python ou Go pour automatiser les tests de votre serveur. Assurez-vous que votre serveur gère bien les requêtes concurrentes, les erreurs, et les charges lourdes sans crasher.
Comportement avec NGINX

Comparaison avec NGINX : Pour toute question sur un comportement spécifique, comparez-le avec NGINX, en particulier pour la gestion des server_name et le traitement des requêtes.
En suivant ces conseils et cet exemple de configuration, vous devriez être en mesure de construire un fichier de configuration robuste pour votre serveur web en C++ qui répond à toutes les exigences spécifiées dans votre projet.


Partie bonus

Voici quelques fonctionnalités supplémentaires que vous pouvez ajouter:
Support cookies et gestion de session(préparez des exemples rapides).
Gérer plusieurs CGI.

1. Support de Cookies et Gestion de Session

Définitions
Cookies : Les cookies sont de petits morceaux de données envoyés par le serveur au navigateur du client, qui les renvoie au serveur à chaque requête HTTP subséquente. Les cookies sont utilisés pour mémoriser des informations sur les utilisateurs entre les différentes pages.

Gestion de Session : Une session peut être définie comme une série d'interactions entre un client et un serveur qui sont liées à un utilisateur spécifique. Les sessions sont utilisées pour conserver l'état entre les transactions HTTP, qui sont par défaut sans état.

Exemple de Cookie
Pour envoyer un cookie au client:

Set-Cookie: sessionId=abc123; Expires=Wed, 09 Jun 2021 10:18:14 GMT

Pour recevoir un cookie du client:

Cookie: sessionId=abc123

Approche pour l'Implémentation

Envoyer un Cookie : Quand un client se connecte pour la première fois, générez un identifiant de session unique et envoyez-le comme cookie.

Recevoir et Valider un Cookie : À chaque requête, extrayez l'identifiant de session du cookie pour maintenir l'état.

Exemple en C++ :
// Pour envoyer un cookie avec un identifiant de session
std::string responseHeader = "Set-Cookie: sessionId=" + generateUniqueId() + "; Path=/; HttpOnly";
send(clientSocket, responseHeader.c_str(), responseHeader.length(), 0);

// Pour recevoir et utiliser un cookie
std::string requestHeader = "Cookie: ";
size_t pos = request.find(requestHeader);
if (pos != std::string::npos) {
    size_t start = pos + requestHeader.length();
    size_t end = request.find(';', start);
    std::string cookie = request.substr(start, end - start);
    // Utiliser `cookie` pour récupérer ou valider la session
}

2. Gérer Plusieurs CGI

Définition
CGI (Common Gateway Interface) : Une méthode utilisée pour générer des pages web dynamiques en permettant au serveur web d'appeler un programme externe et d'envoyer ses sorties au client. Chaque programme peut être écrit dans n'importe quel langage de programmation qui peut être exécuté sur le serveur.

Exemple de Gestion de CGI
Supposons que vous ayez des scripts CGI en PHP et Python que vous voulez exécuter en fonction de l'extension de fichier.

Approche pour l'Implémentation

Configuration des Handlers CGI : Définissez dans votre configuration du serveur quel programme CGI utiliser pour chaque type de fichier.

Exécution de CGI : Lorsqu'une requête arrive pour un fichier correspondant à un type CGI, exécutez le handler approprié et envoyez la sortie générée au client.

Exemple en C++ :

std::map<std::string, std::string> cgiHandlers;
cgiHandlers[".php"] = "/usr/bin/php-cgi";
cgiHandlers[".py"] = "/usr/bin/python";

std::string extension = getFileExtension(requestedPath);
if (cgiHandlers.find(extension) != cgiHandlers.end()) {
    std::string command = cgiHandlers[extension] + " " + requestedPath;
    std::string output = executeCommand(command);
    send(clientSocket, output.c_str(), output.length(), 0);
}

// Fonction auxiliaire pour exécuter des commandes
std::string executeCommand(const std::string& cmd) {
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

Ces exemples montrent comment implémenter le support des cookies, la gestion de session, et comment gérer plusieurs CGI dans un serveur web en C++. Chaque partie de votre serveur nécessite une attention aux détails et une bonne compréhension des protocoles HTTP pour garantir la sécurité et l'efficacité.