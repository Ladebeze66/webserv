Pour la conception de l'architecture de base de votre serveur web en C++, nous devons structurer clairement les différentes classes et modules qui interagiront pour traiter les requêtes, envoyer des réponses, gérer les routes, et exécuter des scripts CGI. Ensuite, nous examinerons comment utiliser les sockets pour établir et gérer les connexions réseau.

Modélisation des Composants

1. Classe Serveur
La classe Server sera responsable de l'initialisation des sockets, de l'écoute des connexions entrantes et de la délégation des requêtes aux gestionnaires appropriés.

Exemple de code pour la classe Serveur :

#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

class Server {
private:
    int server_fd;
    sockaddr_in address;
    int port;

public:
    Server(int port) : port(port) {
        // Créer socket
        server_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (server_fd == 0) {
            perror("socket failed");
            exit(EXIT_FAILURE);
        }

        // Définir l'adresse du serveur
        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(port);

        // Attacher le socket à l'adresse et au port
        if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
            perror("bind failed");
            exit(EXIT_FAILURE);
        }

        // Commencer à écouter les connexions
        if (listen(server_fd, 3) < 0) {
            perror("listen");
            exit(EXIT_FAILURE);
        }
    }

    ~Server() {
        close(server_fd);
    }

    void run() {
        int addrlen = sizeof(address);
        std::cout << "Listening on port " << port << std::endl;
        while (true) {
            int new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen);
            if (new_socket < 0) {
                perror("accept");
                continue;
            }
            // Gérer la nouvelle connexion dans un thread séparé ou via un gestionnaire
            handleConnection(new_socket);
            close(new_socket);
        }
    }

    void handleConnection(int socket);
};

2. Classes Requête et Réponse

Les classes Request et Response manipulent les données entrantes et sortantes. Request parse les requêtes HTTP et Response construit les réponses HTTP.

Exemple de structure pour Request et Response :

class Request {
public:
    std::string method;
    std::string uri;
    std::string httpVersion;
    std::map<std::string, std::string> headers;
    std::string body;

    void parse(const std::string& rawRequest);
};

class Response {
public:
    int statusCode;
    std::map<std::string, std::string> headers;
    std::string body;

    std::string format() const;
};

3. Classe Routeur

Le Router dirige les requêtes vers les gestionnaires spécifiques basés sur l'URI et la méthode HTTP. Cette classe peut également gérer les routes dynamiques et les redirections.

Exemple simplifié :

class Router {
public:
    std::map<std::string, std::function<void(const Request&, Response&)>> routes;

    void addRoute(const std::string& path, std::function<void(const Request&, Response&)> handler) {
        routes[path] = handler;
    }

    bool route(const Request& req, Response& res) {
        if (routes.find(req.uri) != routes.end()) {
            routes[req.uri](req, res);
            return true;
        }
        return false;
    }
};

4. Gestionnaire de CGI

Pour exécuter des scripts externes, la classe CGIHandler peut invoquer des programmes CGI basés sur l'extension du fichier demandé et passer les données de requête.

Exemple simplifié de gestion CGI :

class CGIHandler {
public:
    std::string executeCGI(const std::string& scriptPath, const Request& req) {
        // Implémentation pour exécuter le script et capturer la sortie
    }
};

Gestion des Connexions
Nous avons déjà introduit une gestion basique des sockets dans la classe Server. L'utilisation des fonctions socket(), bind(), listen(), et accept() est cruciale pour la gestion des connexions réseau. Vous devrez également gérer correctement la fermeture des sockets avec close() pour éviter les fuites de ressources.

Cette architecture de base fournit une fondation solide pour votre serveur web en C++. Vous pouvez étendre chaque composant avec des fonctionnalités plus complexes comme la prise en charge de HTTPS, la gestion des sessions, ou des optimisations de performance telles que le multiplexage ou le multithreading.

Il est tout à fait pertinent et même recommandé de séparer les définitions de classe et les déclarations de fonctions dans des fichiers d'en-tête (.hpp) des implémentations correspondantes dans des fichiers source (.cpp). Cette approche apporte plusieurs avantages importants pour le développement de votre serveur web en C++, notamment :

1. Organisation et Lisibilité
Séparer les déclarations et les implémentations aide à maintenir votre code organisé et plus lisible. Les fichiers d'en-tête fournissent une vue d'ensemble des fonctionnalités de la classe (comme une interface), tandis que les fichiers source contiennent les détails techniques de l'implémentation. Cela facilite également la navigation dans le code, surtout dans de grands projets.

2. Réduction des Temps de Compilation
En utilisant des fichiers d'en-tête et des fichiers source distincts, vous réduisez les temps de compilation. Les modifications apportées à l'implémentation d'une classe dans un fichier .cpp n'exigent pas la recompilation des fichiers qui incluent le fichier d'en-tête correspondant, tant que l'interface de la classe reste inchangée.

3. Encapsulation et Gestion des Dépendances
Les fichiers d'en-tête permettent de définir clairement ce qui doit être exposé au reste du programme, favorisant ainsi l'encapsulation. Ils permettent également de gérer les dépendances de manière plus contrôlée, en incluant uniquement ce qui est nécessaire pour l'interface de la classe.

4. Facilite la Maintenance et le Debugging
Avoir une séparation claire entre la logique d'interface et l'implémentation facilite la maintenance et le debugging, car vous pouvez rapidement identifier si un problème est dû à l'utilisation de l'interface de la classe ou à son implémentation interne.


Anticiper la création de classes abstraites est non seulement pertinent mais souvent recommandé dans la perspective d'évolution de votre projet de serveur web en C++. Cette approche présente plusieurs avantages significatifs qui favorisent la flexibilité, l'extensibilité et la maintenabilité de votre code. Voici quelques points clés à considérer :

1. Extensibilité
Les classes abstraites, souvent utilisées pour définir des interfaces en C++, permettent de spécifier un ensemble de fonctionnalités que toutes les classes dérivées doivent implémenter. Cela rend votre application plus facile à étendre car vous pouvez ajouter de nouvelles fonctionnalités ou comportements en dérivant de ces classes abstraites sans modifier le code existant.

2. Réutilisabilité
En définissant des comportements communs dans une classe abstraite, vous évitez la duplication de code et favorisez la réutilisation. Par exemple, si plusieurs parties de votre serveur doivent traiter les requêtes HTTP mais de manière légèrement différente, vous pouvez définir une classe abstraite HttpRequestHandler avec une méthode virtuelle pure handle() que chaque gestionnaire spécifique implémentera.

3. Maintenance
Avec des classes abstraites bien définies, le maintien de votre code devient plus aisé. Les modifications dans la logique de base de l'application peuvent souvent être implémentées dans la classe abstraite, et toutes les classes dérivées bénéficieront de cette mise à jour. Cela réduit le risque d'erreurs et diminue le coût de maintenance.

4. Dépendance sur les Abstractions et non sur les Implémentations
Ce principe de conception (Dependency Inversion Principle) encourage à dépendre d'abstractions plutôt que de classes concrètes, ce qui augmente la modularité de votre application et réduit la dépendance entre les différents composants.

Exemple Conceptuel en C++
Supposons que vous ayez besoin de différents types de gestionnaires de requêtes dans votre serveur, chacun traitant certains types de contenu ou certains protocoles de manière spécifique.

Définition de la classe abstraite

// HttpRequestHandler.hpp
#ifndef HTTPREQUESTHANDLER_HPP
#define HTTPREQUESTHANDLER_HPP

#include "Request.hpp"
#include "Response.hpp"

class HttpRequestHandler {
public:
    virtual ~HttpRequestHandler() = default;
    virtual void handleRequest(const Request& req, Response& res) = 0;
};

#endif // HTTPREQUESTHANDLER_HPP

Implémentation des classes concrètes

// StaticFileHandler.hpp
#include "HttpRequestHandler.hpp"

class StaticFileHandler : public HttpRequestHandler {
public:
    void handleRequest(const Request& req, Response& res) override {
        // Implémenter la logique pour servir des fichiers statiques
    }
};

// ApiHandler.hpp
#include "HttpRequestHandler.hpp"

class ApiHandler : public HttpRequestHandler {
public:
    void handleRequest(const Request& req, Response& res) override {
        // Implémenter la logique pour gérer les appels API
    }
};
Avec cette structure, vous pouvez facilement ajouter d'autres types de gestionnaires pour les différentes routes ou fonctionnalités de votre serveur, sans perturber l'architecture existante.

Conclusion
En anticipant la création de classes abstraites, vous préparez votre projet à une évolution future en simplifiant l'ajout de nouvelles fonctionnalités et en rendant le code plus robuste et plus facile à maintenir. Cette approche est particulièrement bénéfique pour les projets susceptibles de s'agrandir ou de nécessiter des modifications fréquentes.

Structure du Projet
src/
|-- main.cpp
|-- Server.cpp
|-- Server.hpp
|-- Request.cpp
|-- Request.hpp
|-- Response.cpp
|-- Response.hpp
|-- Router.cpp
|-- Router.hpp
|-- HttpRequestHandler.hpp
|-- StaticFileHandler.cpp
|-- StaticFileHandler.hpp