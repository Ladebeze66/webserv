WEBSERV

Comprendre pourquoi les URLs commencent par HTTP

Projet consistant à écrire son propre serveur HTTP.

Introduction

Le protocole HTTP(Hypertext Transfer Protocol) est un protocole d'application pour les systèmes d'information distribués, collaboratifs et hypermédia.
HTTP est la base de la communication de données pour le World Wide Web, où les documents hypertextes incluent des hyperliens vers d'autres ressources auxquelles l'utilisateur peut facilement accéder, par exemple par un clic de souris ou en tapant sur l'écran dans un navigateur Web.
HTTP a été développé pour faciliter l'hypertexte et le World Wide Web.
La fonction principale d'un serveur Web est de stocker, traiter et livrer des pages Web aux clients.
La communication entre le client et le serveur s'effectue à l'aide du protocole HTTP.
Les pages livrées sont le plus souvent des documents HTML, qui peuvent inclure des images, des feuilles de style et des scripts en plus du contenu textuel.
Plusieurs serveurs Wev peuvent être utilisés pour un site Web à fort trafic.
Un agent d'utilisateur, généralement un navigateur Web ou un robot d'indexation Web, initie la communication en faisant une demande pour une ressource spécifique à l'aide de HTTP.
Le serveur répond par le contenu de cettre ressource ou par un message d'erreur s'il est incapable de le faire. La ressource est généralement un fichier réel sur le stockage secondaire du serveur, mais ce n'est pas nécessairement le cas et dépend de la manière dont le serveur Web est implémenté.

Partie obligatoire:
Nom du programme: webserv
Fichiers de rendu: Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp, des fichiers de configuration
Arguments: un fichier de configuration
Fonctions externes autorisées: Tout ce qui respecte la norme C++ 98.
execve: exécute un programme référencé par un fichier spécifié dans un nouveau contexte de processus.
dup et dup2: 'dup' duplique un descripteur de fichier, rendant une copie qui partage toutes les locks de fichiers et les positions de lecture/écriture avec l'original. 'dup2' fait de même mais permet de spécifier le nouveaau descripteur de fichier.
pipe: crée une paire de descripteurs de fichiers, reliés entre eux, permettant la communication unidirectionnelle(données écrites sur un descripteur peuvent être lues de l'autre).
strerror et gai_streerror: le premier traduit un code d'erreur numérique en un message explicatif. Le second fait de même pour les erreurs retournées par les fonctions de résolution d'adresse réseau.
errno: variable globale utilisée par de nombreuses fonctions du système pour indiquer le type d'erreur lorqu'une opération échoue.
fork: crée un nouveau processus en dupliquant le processus appelant.
socketpair: crée une paire de sockets connectés, permettant la communication bidirectionnelle.
htons, htonl, ntohs, ntohl: convertissent les valeurs entre l'ordre des octets hôte et l'ordre des octects réseau pour les short et les long.
select: permet à un programme de surveillers plusieurs descripteurs de fichiers, attendant qu'un ou plusieurs deviennent "prêts" pour une opération d'entrée/sortie.
poll: similaire à select, mais fournit plus de fonctionnalités et une meilleure échelle pour les systèmes avec de nombreux descripteurs.
epoll(epoll_create, epoll_ctl, epoll_wait): mécanisme d'entrée/sortie évènementiel utilisé pour suveiller plusieurs descipteurs sous Linux.
Kqueue(kqueue, kevent): interface similaire à epoll mais disponible sur les systèmes BSD pour surveiller divers types d'événements.
socket, accept, listen, send, recv: fonctions utilisées pour la communication sur les réseaux via des sockets.
chdir, bind, connect, getaddrinfo, freeaddrinfo: fonctions pour la manipulation  de répertoires, la liaison de sockets, la connexion, la résolution d'adresses, et la getion de la mémoire pour les structures d'adresse.
setsockopt, getsockname, getprotobyname, fcntl, close: fonctions pour configurer les options des sockets, obtenir des informations socket, manipuler les propriétés des fichiers et descripteurs.
read, write: fonctions de base pour lire et écrire des données sur des descripteurs de fichiers.
waitpid, kill, signal: fonxtions pour la gestion des processus, l'envoi de signaux et la manipulation des gestionnaires de signaux.
access, stat: fonctions pour vérifier les permissions d'accès et obtenir les informations de statut des fichiers.
open, opendir, readdir, closedir: fonctions pour ouvrir, lire, et fermer des fichiers et répertoires.

Vous devez écrire un serveur HTTP en C++ 98.

Bien que poll() soit mentionné dans le sujet et la grille d'évaluation, vous pouvez utiliser un équivalent tel que select(), kqueue(), ou epoll().

Veuillez lire la RFC et faire quelques tests avec telnet et NGINX avant de commencer ce projet. Même si vous n'avez pas à implémenter toute la RFC, cela vous aidera à développer les fonctionnatlités requises.

La RFC (Request for Comments) concernant le protocole HTTP est une série de documents qui décrivent les spécifications techniques du protocole utilisé par le World Wide Web. Pour un serveur web, les RFC les plus pertinentes sont celles qui décrivent HTTP/1.1, car elles fournissent une base détaillée sur la manière dont les requêtes et les réponses doivent être gérées.

RFCs importantes pour HTTP/1.1 :
RFC 7230 : Architecture et messages HTTP/1.1
Détaille la syntaxe des messages, le transport des messages, et la connexion entre les clients et les serveurs.
RFC 7231 : Sémantique et contenu
Définit les méthodes de requête (GET, POST, etc.), les codes de statut de réponse, et les en-têtes qui déterminent le contenu de la requête et de la réponse.
RFC 7232 : Gestion des conditions préalables
Spécifie des en-têtes tels que Last-Modified et ETag pour gérer le cache et les conditions de requête.
RFC 7233 : Gestion des plages de requêtes
Permet à un client de demander des portions spécifiques d'une ressource, ce qui est utile pour le téléchargement de gros fichiers.
RFC 7234 : Mise en cache
Décrit les comportements de mise en cache et les directives de cache, qui contrôlent la réutilisation des réponses.
RFC 7235 : Authentification
Explique comment les requêtes et les réponses doivent gérer l'authentification et la sécurisation des accès.

Pourquoi lire la RFC est utile ?
Compatibilité et Interopérabilité : Assurer que votre serveur peut interagir correctement avec d'autres clients et serveurs Internet.
Fiabilité : Comprendre les normes aide à prévenir les erreurs de communication et à gérer efficacement les erreurs et les situations exceptionnelles dans les requêtes ou les réponses.
Performance : Les RFC détaillent les meilleures pratiques pour optimiser les communications, comme la gestion efficace des connexions persistantes et la mise en cache.
Sécurité : Inclut des recommandations pour sécuriser les échanges, comme l'utilisation de HTTPS et les méthodes d'authentification(cf documents RCF importants en pièce jointe).

En comprenant bien ces documents, vous aurez une base solide pour développer un serveur web qui respecte les standards actuels.

Utilisation de Telnet
Telnet est un protocole réseau qui permet de communiquer avec un autre ordinateur sur un réseau. Il est souvent utilisé pour tester les serveurs web en envoyant manuellement des requêtes HTTP.

Tester des requêtes HTTP :
Ouvrez un terminal et tapez telnet [adresse IP ou nom de domaine] [port]. Par exemple : telnet localhost 80 pour accéder à un serveur local sur le port 80.
Une fois connecté, vous pouvez taper des requêtes HTTP. Par exemple, pour demander la racine du serveur :
GET / HTTP/1.1
Host: localhost

N'oubliez pas d'appuyer deux fois sur "Entrée" après avoir saisi l'en-tête "Host".
Comprendre les réponses :
Observez les réponses retournées par le serveur. Telnet vous permet de voir exactement ce que le serveur envoie en réponse à vos requêtes, ce qui est crucial pour comprendre comment gérer les requêtes dans votre serveur web.
Débogage :
Utilisez Telnet pour envoyer différentes sortes de requêtes HTTP à votre serveur et voyez comment il réagit. Cela peut vous aider à identifier et corriger des erreurs dans la gestion des requêtes.

Utilisation de NGINX
NGINX est un serveur web/populaire qui peut également servir de proxy inverse, de répartiteur de charge, etc. Il est reconnu pour sa légèreté et sa capacité à gérer un grand nombre de connexions simultanées.

Installation et configuration de base :
Installez NGINX sur votre système. Sous Ubuntu, cela peut se faire via sudo apt install nginx.
Configurez NGINX en modifiant le fichier de configuration, souvent situé dans /etc/nginx/nginx.conf ou /etc/nginx/sites-available/default.
Tester et apprendre :
Modifiez la configuration pour servir des pages HTML statiques ou pour agir comme proxy pour votre application C++. Testez ces configurations en accédant à votre serveur NGINX depuis un navigateur ou en utilisant Telnet.
Consultez la documentation de NGINX pour comprendre les différentes directives de configuration et comment elles influencent le comportement du serveur.
Simuler des environnements de production :
Utilisez NGINX comme façade pour votre serveur C++ pour simuler un environnement de production et voir comment votre serveur se comporte sous charge, comment il gère les erreurs, etc.

Prérequis
